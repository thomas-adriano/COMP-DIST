package com.taxifleet.server;

import java.net.InetAddress;
import java.net.UnknownHostException;
import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import com.taxifleet.server.network.NetworkNode;
import com.taxifleet.server.network.NetworkRequest;
import com.taxifleet.server.network.rmi.NetworkNodes;
import com.taxifleet.server.network.rmi.RmiClient;
import com.taxifleet.server.network.rmi.RmiClient.RemoteObjectRetriever;
import com.taxifleet.server.network.rmi.RmiServer;
import com.taxifleet.server.network.rmi.RmiServer.RemoteObjectBinder;
import com.taxifleet.server.network.rmi.TaxiServers;
import com.taxifleet.server.network.socket.MulticastSocketMessageSender;
import com.taxifleet.server.network.socket.ShoutRequestListener;
import com.taxifleet.server.network.socket.ShoutResponseListener;
import com.taxifleet.server.network.socket.SocketMessageSender;
import com.taxifleet.utils.ByteArrayUtils;
import com.taxifleet.utils.TimerExecutor;

//TODO ver necessidade de listener estarem em threads. Socket.accept() e DatagramSocket.receive() já tem o comportamento que eu busco utilizando Threads
public class BasicServer implements TaxiServer {

	/**
	 * 
	 */
	private static final long serialVersionUID = 8434299929425496749L;
	private RmiClient rmiClient;
	private RmiServer rmiServer;
	private RemoteObjectRetriever retriever;
	private RemoteObjectBinder binder;
	private Context context;
	private static NetworkNodes networkNodes;
	private List<NetworkObserver> observers;
	private SocketMessageSender sender;
	private static final Logger LOGGER = LogManager.getLogger(TaxiServer.class);

	public static void main(String[] args) {
		BasicServer s;
		try {
			s = new BasicServer(InetAddress.getLocalHost());
			s.checkIn();
		} catch (UnknownHostException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	public BasicServer(InetAddress localAddress) {
		context = Context.getContext();
		LOGGER.info("Starting server: "
				+ context.getLocalAddress().getHostAddress());

	}

	@Override
	public void checkIn() {
		LOGGER.info("Starting checkIn procedure...");

		// TODO SRP startShoutResponseListener
		ShoutResponse response = startShoutResponseListener();
		startShoutRequestListener();

		if (response.isEmpty()) {
			LOGGER.info("No one replyed shout message ;(");
		} else {
			try {
				InetAddress networkNodeAddr = InetAddress
						.getByAddress(ShoutResponse
								.getShoutResponseIp(response));

				initRmiClient(networkNodeAddr);
				stabilishConnection();

			} catch (UnknownHostException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}

		initRmiServer();

	}

	private void initRmiClient(InetAddress networkNodeAddr) {
		rmiClient = new RmiClient();

		retriever = rmiClient.startClient(networkNodeAddr);
	}

	private void stabilishConnection() {
		networkNodes = retriever.rerieve(NetworkNodes.REMOTE_NAME);

		try {
			networkNodes.registerNode(this);
			Iterator<NetworkNode> it = networkNodes.getIterator();
			int nodesCounter = 0;
			while (it.hasNext()) {
				nodesCounter++;
			}
			System.err.println("Total nodes connected: " + nodesCounter);
			// TODO ver maneira de fazer os nodes serem atualizados
			// quando um node se conectar a uma rede pre-existente, o
			// node ingressante terá que se registrar como observer dos
			// nodes preexistentes e os preexistentes terão que se
			// registrar como observers do node ingressante
			notifyObservers();
		} catch (RemoteException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	private void initRmiServer() {
		networkNodes = TaxiServers.getInstance();
		try {
			networkNodes.registerNode(this);
			rmiServer = new RmiServer();
			LOGGER.info("Starting RMI Server...");
			binder = rmiServer.startServer();
			binder.bindRemoteObject(NetworkNodes.REMOTE_NAME, networkNodes);
		} catch (RemoteException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	private ShoutResponse startShoutResponseListener() {
		ShoutResponseListener shoutResponseListener = new ShoutResponseListener(
				context.getDefaultMulticastMessagesListenerInterval(),
				context.getUnicastPort());
		Thread shoutListener = new Thread(shoutResponseListener);
		shoutListener.start();
		// Força a execução de shoutListener antes da chamada do metodo shout()
		TimerExecutor.sleepCurrentThread(500);

		shout();
		// Aguarda uma resposta para shout nos proximos 5s
		TimerExecutor.sleepCurrentThread(context
				.getDefaultShoutResponseTimeout());
		// Interrompe shoutListener. Se ninguem tiver respondido ao shout(),
		// este servidor é o único da rede.
		// Obs.: o ShoutRequestListenerTimer contina rodando para antender a
		// novas entradas na rede
		shoutListener.interrupt();

		return shoutResponseListener.getShoutResponse();
	}

	private void startShoutRequestListener() {
		LOGGER.trace("Starting Shout Request Listener.");
		Thread shoutListener = new Thread(new ShoutRequestListener(
				context.getDefaultMulticastMessagesListenerInterval(),
				context.getMulticastGroupAddress(), context.getLocalAddress()));
		shoutListener.start();

	}

	@Override
	public void shout() {
		LOGGER.trace("Sending Shout Request...");
		if (sender == null)
			sender = new MulticastSocketMessageSender(
					context.getMulticastGroupAddress(),
					context.getMulticastPort());

		NetworkRequest shoutMessage = new ShoutRequest();

		sender.sendMessage(shoutMessage);
	}

	// provavelmente precisará de algum parametro, e será chamado em algum
	// ListenerTimer
	@Override
	public void sendNetAddress() {

	}

	@Override
	public void startListeningTimers(long time) {

	}

	@Override
	public void update(NetworkObservable s) {

	}

	@Override
	public void notifyObservers() {
		if (observers == null)
			return;

		for (NetworkObserver o : observers) {
			o.update(this);
		}
	}

	@Override
	public void registerObserver(NetworkObserver o) {
		if (observers == null) {
			observers = new ArrayList<>();
		}
		observers.add(o);
	}

	@Override
	public void addTaxi(Taxi taxi) {
		// TODO Auto-generated method stub

	}

	@Override
	public void removeTaxi(Taxi taxi) {
		// TODO Auto-generated method stub

	}

	@Override
	public Collection<Taxi> getTaxiList() {
		// TODO Auto-generated method stub
		return null;
	}

}
